package contest.winter2017;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;

import com.google.gson.JsonParseException;

import contest.winter2017.Tester.TesterOptions;


/**
 * Entry-point class for the black-box testing framework 
 * 
 * @author IDT
 */
public class Main {
	private static final String JACOCO_AGENT_FILENAME = "jacocoAgent.jar";

	/**
	 * suffix for all jacoco output files
	 */
	private static final String JACOCO_OUTPUT_FILE_SUFFIX = "_jacoco.exec";

	/**
	 * cli key for path to the executable black-box jar to test
	 */
	public static final String JAR_TO_TEST_PATH = "jarToTestPath";

	/**
	 * cli key for path to the directory to be used to store output generated by 
	 * jacoco framework
	 */
	public static final String JACOCO_OUTPUT_PATH = "jacocoOutputPath";

	/**
	 * cli key for path to the jacoco agent jar used to instrument the executable
	 * black-box jar in order to collect code coverage metrics
	 */
	public static final String JACOCO_AGENT_JAR_PATH = "jacocoAgentJarPath";

	/**
	 * cli key for application help
	 */
	public static final String HELP = "help";

	/**
	 * alternative cli key for application help
	 */
	public static final String ALT_HELP = "h";

	/**
	 * option to enable/disable converting tests to json
	 */
	public static final String NO_CONVERT_TO_JSON = "noJson";

	/**
	 * number of exploratory black box tests to run
	 */
	public static final String TEST_ITERATIONS = "bbTests";

	/**
	 * test time goal
	 */
	public static final String TEST_TIME = "timeGoal";

	/**
	 * only output YAML
	 */
	public static final String ONLY_YAML = "toolChain";

	/**
	 * output more information
	 */
	public static final String ENABLE_VERBOSE = "verbose";

	/**
	 * number of threads to use for basic tests
	 */
	public static final String BASIC_TEST_THREADS = "basicThreads";

	private static final Option[] CLI_OPTION_LIST = new Option[] {
			// paths
			Option.builder(JAR_TO_TEST_PATH).hasArg(true).required(true)
				.desc("path to the executable jar to test").build(),
			Option.builder(JACOCO_OUTPUT_PATH).hasArg(true)
				.desc("path to directory for jacoco output").build(),
			Option.builder(JACOCO_AGENT_JAR_PATH).hasArg(true)
				.desc("path to the jacoco agent jar").build(),

			// numbers
			Option.builder(TEST_ITERATIONS).hasArg(true)
				.desc("number of exploratory black box tests to run (default: 1000 iterations)").build(),
			Option.builder(TEST_TIME).hasArg(true)
				.desc("maximum time limit for exploratory black box tests to run (default: 300 seconds)").build(),
			Option.builder(BASIC_TEST_THREADS).hasArg(true)
				.desc("number of threads to use for basic tests (default: 5 threads)").build(),

			// boolean options
			Option.builder(NO_CONVERT_TO_JSON)
				.desc("disable converting test cases to json").build(),
			Option.builder(ONLY_YAML)
				.desc("only output YAML summary").build(),
			Option.builder(ENABLE_VERBOSE)
				.desc("enable output of additional information").build(),
			Option.builder(ALT_HELP).longOpt(HELP)
				.desc("display this help message").build()
	};


	/**
	 * Entry-point method for the black-box testing framework 
	 * 
	 * @param args - String array of command line arguments
	 */
	public static void main(String[] args) {
		CommandLineParser parser = new DefaultParser();
		Options options = getCliOptions();
		CommandLine cliArgs;

		try {
			cliArgs = parser.parse(options, args);
			assert cliArgs != null;
		} catch (ParseException exp) {
			System.err.println("An error occurred during command line parsing: " + exp.getMessage());
			return;
		}

		if (cliArgs.hasOption(JAR_TO_TEST_PATH)) {
			TesterOptions testerOptions;
			try {
				testerOptions = parseArguments(cliArgs);
			} catch (IOException ex) {
				ex.printStackTrace();
				return;
			}

			Tester tester = new Tester();
			try {
				tester.init(testerOptions);
			}
			catch (IOException | ReflectiveOperationException | JsonParseException e) {
				System.out.println("ERROR: An exception occurred during initialization.");
				e.printStackTrace();
				return;
			}

			// execute tests
			tester.executeBasicTests();
			tester.executeSecurityTests();
			tester.printYaml();
		}

		// if the user has requested help
		else if (cliArgs.hasOption(HELP) || cliArgs.hasOption(ALT_HELP)) {
			printHelp(options);
		}

		// user did not request help and we had an inadequate number of arguments
		else {
			System.err.println("Failed to execute - the -" + JAR_TO_TEST_PATH + " argument is required.");
			printHelp(options);
		}
	}

	private static Options getCliOptions() {
		Options options = new Options();
		for (Option option : CLI_OPTION_LIST) {
			options.addOption(option);
		}
		return options;
	}


	private static TesterOptions parseArguments(CommandLine cliArgs) throws IOException {
		TesterOptions options = new TesterOptions();

		// get jarToTestPath
		assert cliArgs.hasOption(JAR_TO_TEST_PATH);
		options.jarToTestPath = cliArgs.getOptionValue(JAR_TO_TEST_PATH);

		// get testFilePath
		File jarToTestFile = new File(options.jarToTestPath);
		File testFile = new File(jarToTestFile.getParent(), jarToTestFile.getName().replaceFirst("[.][^.]+$", "") + ".json");
		options.jsonFilePath = testFile.getAbsolutePath();

		// get jacocoOutputDirPath
		if (cliArgs.hasOption(JACOCO_OUTPUT_PATH)) {
			options.jacocoOutputDirPath = cliArgs.getOptionValue(JACOCO_OUTPUT_PATH);
		} else {
			options.jacocoOutputDirPath = createTempDir().getAbsolutePath();
			// delete temporary jacoco output directory on exit
			Runtime.getRuntime().addShutdownHook(new Thread(() -> FileUtils.deleteQuietly(new File(options.jacocoOutputDirPath))));
		}

		// determine jacocoOutputFilePath
		options.jacocoOutputFilePath = Paths.get(
				options.jacocoOutputDirPath,
				FilenameUtils.removeExtension(jarToTestFile.getName()) + JACOCO_OUTPUT_FILE_SUFFIX
			).toString();

		File jacocoOutputFile = new File(options.jacocoOutputFilePath);
		if (jacocoOutputFile != null && jacocoOutputFile.exists()) {
			jacocoOutputFile.delete();
		}

		// get jacocoAgentJarPath
		if (cliArgs.hasOption(JACOCO_AGENT_JAR_PATH)) {
			options.jacocoAgentJarPath = cliArgs.getOptionValue(JACOCO_AGENT_JAR_PATH);
		}
		else {
			try {
				File tempFile = extractBundledJacocoJar();
				options.jacocoAgentJarPath = tempFile.getAbsolutePath();
				tempFile.deleteOnExit();
			}
			catch (IOException ex) {
				System.err.println("Error: Unable to extract Jacoco Agent jar!");
				System.err.println("You can use the -" + JACOCO_OUTPUT_PATH + " option to specify the agent file.");
				throw ex;
			}
		}

		// get numThreads
		options.numThreads = 1;
		if (cliArgs.hasOption(BASIC_TEST_THREADS)) {
			try {
				options.numThreads = Integer.parseInt(cliArgs.getOptionValue(BASIC_TEST_THREADS));
			}
			catch (NumberFormatException ex) {
				System.err.println("Error: Unable to parse numThreads");
				throw ex;
			}
		}

		options.yamlOnly = cliArgs.hasOption(ONLY_YAML);
		options.verbose = cliArgs.hasOption(ENABLE_VERBOSE);
		options.disableJsonConversion = cliArgs.hasOption(NO_CONVERT_TO_JSON);

		return options;
	}

	private static File createTempDir() throws IOException {
		return Files.createTempDirectory("jacocoOutput").toFile();
	}

	/**
	 * Reads Jacoco agent jar bundled with this project into a temporary file.
	 * @return path to the temporary file
	 * @throws IOException
	 */
	private static File extractBundledJacocoJar() throws IOException {
		// read file bundled with this project
		InputStream fileStream = Main.class.getResourceAsStream("/" + JACOCO_AGENT_FILENAME);
		assert fileStream != null;

		// open temporary output file
		File tempFile = File.createTempFile("jacocoJar", JACOCO_AGENT_FILENAME);
		tempFile.deleteOnExit();

		// copy to file and close
		FileUtils.copyInputStreamToFile(fileStream, tempFile);

		return tempFile;
	}

	/**
	 * private static method used to print the application help
	 */
	private static void printHelp(Options options) {
		String header = "\n";
		String footer = "\nFor additional information about the testing framework, please see the documentation provided with this application.";

		HelpFormatter formatter = new HelpFormatter();
		formatter.printHelp("com.idtus.contest.winter2017.framework", header, options, footer, true);
	}

}
